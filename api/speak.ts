
import { GoogleGenAI } from "@google/genai";
import type { VercelRequest, VercelResponse } from '@vercel/node';

export default async function handler(req: VercelRequest, res: VercelResponse) {
    if (req.method !== 'POST') {
        res.setHeader('Allow', ['POST']);
        return res.status(405).json({ error: 'Method Not Allowed' });
    }

    let body = req.body;
    if (typeof body === 'string') {
        try {
            body = JSON.parse(body);
        } catch (e) {
            console.error("Failed to parse body:", e);
            return res.status(400).json({ error: 'Invalid JSON body' });
        }
    }

    const { text, voice, speakers } = body;

    if (!text) {
        return res.status(400).json({ error: 'Text is required.' });
    }

    const apiKey = process.env.API_KEY;
    if (!apiKey) {
        return res.status(500).json({ error: 'Server Error: API Key missing.' });
    }

    const client = new GoogleGenAI({ apiKey });

    // CRITICAL UPDATE: 
    // Switching to 'gemini-2.0-flash-exp' because the user confirmed it has UNLIMITED quota.
    // The specialized 'gemini-2.5-flash-preview-tts' is locked at 15 requests/day.
    const MODEL_NAME = 'gemini-2.0-flash-exp';

    const selectedVoiceName = speakers?.speakerA?.voice || voice || 'Puck';

    // Map the UI voice names (Puck, Kore, etc.) to descriptive prompts
    // because Gemini 2.0 doesn't support 'speechConfig' params.
    const getVoiceStyle = (vName: string) => {
        switch (vName) {
            case 'Puck': return 'a clear, well-modulated British male voice';
            case 'Charon': return 'a deep, authoritative male voice';
            case 'Fenrir': return 'an energetic, fast-paced male voice';
            case 'Kore': return 'a calm, soothing female voice';
            case 'Zephyr': return 'a cheerful, bright female voice';
            default: return 'a professional narrator voice';
        }
    };

    const voiceStyle = getVoiceStyle(selectedVoiceName);
    
    // Construct a prompt that forces audio output
    const prompt = `Please read the following text aloud using ${voiceStyle}. Do not add any introductory text, just read the content: "${text}"`;

    try {
        const response = await client.models.generateContent({
            model: MODEL_NAME,
            contents: {
                role: 'user',
                parts: [{ text: prompt }]
            },
            config: {
                responseModalities: ['AUDIO'],
                // NOTE: We deliberately removed 'speechConfig' here.
                // It causes 400 Invalid Argument errors with the 2.0 model.
                // We rely on the prompt above to style the voice.
            },
        });

        const audioData = response.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;

        if (audioData) {
            res.setHeader('Content-Type', 'application/json');
            return res.status(200).json({ audioContent: audioData, modelUsed: MODEL_NAME });
        } else {
            console.error("Gemini 2.0 returned no audio data.");
            return res.status(500).json({ error: "No audio generated by the model." });
        }

    } catch (error: any) {
        console.error("Gemini 2.0 Generation Error:", error);
        
        const errMsg = error.message || error.toString();
        
        // Handle Quota/Busy errors specifically
        if (errMsg.includes('429') || errMsg.includes('quota') || errMsg.includes('busy')) {
             return res.status(429).json({ 
                 error: "Server busy. Please try again in a moment.", 
                 details: errMsg 
             });
        }
        
        return res.status(500).json({ error: "Generation failed.", details: errMsg });
    }
}
